{"ast":null,"code":"import { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, ADORNMENT_SIZE, FLAT_INPUT_OFFSET } from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nexport const calculateLabelTopPosition = function (labelHeight) {\n  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport const calculateInputHeight = function (labelHeight) {\n  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let minHeight = arguments.length > 2 ? arguments[2] : undefined;\n  const finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport const calculatePadding = props => {\n  const {\n    height,\n    multiline = false\n  } = props;\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = props => {\n  const {\n    dense\n  } = props;\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = _ref => {\n  let {\n    topPosition,\n    fontSize,\n    multiline,\n    scale,\n    dense,\n    offset,\n    isAndroid\n  } = _ref;\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\n\nexport const adjustPaddingOut = _ref2 => {\n  let {\n    pad,\n    multiline,\n    label,\n    scale,\n    height,\n    fontSize,\n    lineHeight,\n    dense,\n    offset,\n    isAndroid\n  } = _ref2;\n  const fontHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2)\n    };\n  }\n\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n\n    result = Math.floor(result);\n  }\n\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport const adjustPaddingFlat = _ref3 => {\n  let {\n    pad,\n    scale,\n    multiline,\n    label,\n    height,\n    offset,\n    dense,\n    fontSize,\n    isAndroid,\n    styles\n  } = _ref3;\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const {\n    paddingTop,\n    paddingBottom\n  } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return {\n        paddingTop,\n        paddingBottom\n      };\n    } // return pad for flat input without label\n\n\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom; // adjust top padding for iOS\n\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    } // adjust paddings for iOS if no label\n\n\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport const interpolatePlaceholder = (labeled, hasActiveOutline) => labeled.interpolate({\n  inputRange: [0, 1],\n  outputRange: [hasActiveOutline ? 0 : 1, 1]\n});\nexport function calculateFlatAffixTopPosition(_ref4) {\n  let {\n    height,\n    paddingTop,\n    paddingBottom,\n    affixHeight\n  } = _ref4;\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  const halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition(_ref5) {\n  let {\n    height,\n    affixHeight,\n    labelYOffset\n  } = _ref5;\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport const calculateFlatInputHorizontalPadding = _ref6 => {\n  let {\n    adornmentConfig\n  } = _ref6;\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(_ref7 => {\n    let {\n      type,\n      side\n    } = _ref7;\n\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft,\n    paddingRight\n  };\n};","map":{"version":3,"mappings":"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","names":["LABEL_PADDING_HORIZONTAL","ADORNMENT_OFFSET","ADORNMENT_SIZE","FLAT_INPUT_OFFSET","AdornmentType","AdornmentSide","calculateLabelTopPosition","labelHeight","height","optionalPadding","customHeight","Math","floor","calculateInputHeight","minHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","max","dense","_ref","topPosition","fontSize","scale","offset","isAndroid","refFontSize","min","adjustPaddingOut","_ref2","pad","label","lineHeight","fontHeight","refFontHeight","paddingTop","paddingBottom","adjustPaddingFlat","_ref3","styles","topResult","bottomResult","interpolatePlaceholder","labeled","hasActiveOutline","interpolate","inputRange","outputRange","calculateFlatAffixTopPosition","affixHeight","_ref4","inputHeightWithoutPadding","halfOfTheInputHeightDecreasedByAffixHeight","calculateOutlinedIconAndAffixTopPosition","labelYOffset","_ref5","calculateFlatInputHorizontalPadding","_ref6","adornmentConfig","paddingLeft","paddingRight","forEach","_ref7","type","side","Icon","Left","Right","Affix"],"sources":["/Users/kuidou/Documents/CS/5098/demo-a-java-tutor copy/frontend/node_modules/react-native-paper/lib/module/components/TextInput/helpers.tsx"],"sourcesContent":["import type { Animated } from 'react-native';\nimport type { AdornmentConfig } from './Adornment/types';\nimport {\n  LABEL_PADDING_HORIZONTAL,\n  ADORNMENT_OFFSET,\n  ADORNMENT_SIZE,\n  FLAT_INPUT_OFFSET,\n} from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nimport type { TextInputLabelProp } from './types';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  lineHeight?: number;\n  label?: TextInputLabelProp | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const fontHeight = lineHeight ?? fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontHeight / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontHeight * scale)\n            : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport const interpolatePlaceholder = (\n  labeled: Animated.Value,\n  hasActiveOutline: boolean | undefined\n) =>\n  labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1],\n  });\n\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight,\n}: {\n  height: number;\n  paddingTop: number;\n  paddingBottom: number;\n  affixHeight: number;\n}): number {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n\n  const halfOfTheInputHeightDecreasedByAffixHeight =\n    (inputHeightWithoutPadding - affixHeight) / 2;\n\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\n\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset,\n}: {\n  height: number;\n  affixHeight: number;\n  labelYOffset: number;\n}): number {\n  return (height - affixHeight + labelYOffset) / 2;\n}\n\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n}: {\n  adornmentConfig: AdornmentConfig[];\n}) => {\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n\n  adornmentConfig.forEach(({ type, side }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n\n  return { paddingLeft, paddingRight };\n};\n"]},"metadata":{},"sourceType":"module"}